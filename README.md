# AI Desktop Assistant with Master Control Programs (MCPs)

Этот проект представляет собой настольное приложение с графическим интерфейсом (GUI), которое позволяет взаимодействовать с мощной языковой моделью (LLM) и давать ей возможность управлять вашим компьютером и внешними сервисами через специализированные модули, называемые **Master Control Programs (MCPs)**.

MCPs - это отдельные, легковесные микросервисы, которые предоставляют ИИ доступ к конкретным возможностям системы или сторонних сервисов (например, файловая система, командная строка, буфер обмена, веб-браузер, Telegram, семантическая память) через стандартизированный JSON-RPC интерфейс.

![Screenshot - Предполагаемый вид приложения с чатом, логами и списком чатов](https://placehold.co/800x600/png?text=UI+Screenshot+Placeholder%0A(Chat%2C+Logs%2C+Chats+List))
*(Изображение GUI является placeholder'ом, замените его реальным скриншотом)*

## Особенности

*   **GUI на PyQt5:** Интуитивно понятный интерфейс для чата, управления историей и настройками.
*   **Интеграция с OpenAI API:** Использует модели семейства OpenAI (или совместимые API) для обработки запросов.
*   **Многомодульная архитектура (MCPs):** Возможность легко добавлять новые инструменты и возможности для ИИ.
    *   **MCP_Files:** Управление файлами в ограниченной "песочнице" (`./workspace`).
    *   **MCP_Shell:** Выполнение команд командной строки из "белого списка" разрешенных команд.
    *   **MCP_Clipboard:** Чтение и запись данных в буфер обмена ОС.
    *   **MCP_Web:** Управление веб-браузером (на основе Selenium) для навигации, получения контента и взаимодействия с элементами страницы.
    *   **MCP_Telegram:** Отправка сообщений, чтение истории диалогов и просмотр участников чатов в Telegram через API Telethon.
    *   **MCP_Semantic_Memory:** Долгосрочная память на основе векторного поиска (FAISS + Sentence-Transformers) и простой граф знаний (NetworkX).
*   **Интеллектуальный цикл "Мысль -> Действие":** ИИ анализирует задачу, планирует шаги ("Мысль"), вызывает соответствующие инструменты (MCPs - "Действие"), обрабатывает результаты и повторяет цикл до получения финального ответа.
*   **Управление чатами:** Сохранение, загрузка и удаление истории переписки в локальные JSON-файлы.
*   **Настраиваемый интерфейс:** Смена цветовой темы (светлая/темная) и настройка размера шрифтов.
*   **Подробные логи:** Отображение рабочего процесса ИИ, включая вызовы MCP, в отдельной панели логов.

## Структура проекта

```
.
├── chat_manager.py           # Управление историей чатов
├── main.py                   # Точка входа, запуск GUI и MCP, ожидание готовности MCP
├── ai_interface.py           # Orchestrator ИИ + MCP, ReAct логика, вызовы OpenAI
├── mcp_clipboard.py          # MCP: Доступ к буферу обмена
├── mcp_files.py              # MCP: Доступ к файловой системе (песочница)
├── mcp_shell.py              # MCP: Выполнение команд ОС (белый список), получение времени
├── mcp_semantic_memory.py    # MCP: Семантическая память (векторы+граф)
├── mcp_telegram.py           # MCP: Интеграция с Telegram API
├── mcp_web.py                # MCP: Управление веб-браузером (Selenium)
├── themes.py                 # Определение цветовых тем QSS для GUI
├── UI.py                     # GUI (окна, виджеты), обработка сигналов, AIWorker (поток ИИ)
├── settings_manager.py       # Управление пользовательскими настройками
├── requirements.txt          # Список Python зависимостей
├── .env.example              # Пример файла с переменными окружения
├── settings.json             # Файл пользовательских настроек (генерируется/обновляется GUI)
└── semantic_memory.db        # База данных для семантической памяти (SQLite)
└── semantic_memory.index     # Индекс FAISS для векторов (бинарный)
└── knowledge_graph.json      # Граф знаний (JSON)
└── chats/                    # Директория для сохранения историй чатов (JSON)
└── workspace/                # Рабочая директория для MCP_Files
└── chromedriver.exe          # Исполняемый файл ChromeDriver (зависит от ОС)
```

## Предварительные требования

1.  **Python 3.8+:** Убедитесь, что у вас установлен Python. [Скачать Python](https://www.python.org/downloads/).
2.  **ChromeDriver:** Для работы MCP_Web требуется исполняемый файл ChromeDriver, совместимый с установленной версией вашего браузера Google Chrome.
    *   [Скачать ChromeDriver](https://chromedriver.chromium.org/downloads).
    *   Поместите `chromedriver.exe` (или соответствующий файл для вашей ОС) в корень проекта или убедитесь, что его директория добавлена в переменную среды PATH вашей операционной системы.
3.  **Аккаунты и API-ключи:**
    *   Аккаунт и API-ключ OpenAI или доступ к совместимому API.
    *   Аккаунт Telegram и получение `api_id` и `api_hash`. Инструкции можно найти в [документации Telethon](https://docs.telethon.dev/en/latest/basic/signing-in.html#programmatically).

## Установка

1.  Клонируйте репозиторий:
    ```bash
    git clone <ссылка_на_ваш_репозиторий>
    cd <имя_папки_проекта>
    ```
2.  Установите зависимости Python:
    ```bash
    pip install -r requirements.txt
    ```
3.  Настройте файл `.env`:
    *   Скопируйте `.env.example` в `.env`: `copy .env.example .env` (Windows) или `cp .env.example .env` (Linux/macOS).
    *   Отредактируйте файл `.env`, заполнив необходимые поля:
        ```env
        # OpenAI/Совместимый API
        OPENAI_API_KEY="ВАШ_API_КЛЮЧ"
        # OPENAI_API_BASE="https://api.openai.com/v1" # Укажите, если используете не стандартный URL OpenAI (например, для локальных моделей или других провайдеров)
        # SELECTED_MODEL="openai/gpt-4o" # Модель по умолчанию (можно выбрать в GUI)

        # Telegram API (нужно получить api_id и api_hash по инструкции Telethon)
        TELEGRAM_API_ID="ВАШ_API_ID_TELEGRAM"
        TELEGRAM_API_HASH="ВАШ_API_HASH_TELEGRAM"

        # Порты для MCP (можно оставить значения по умолчанию)
        MCP_FILES_PORT=8001
        MCP_WEB_PORT=8002
        MCP_SHELL_PORT=8003
        MCP_CLIPBOARD_PORT=8004
        MCP_TELEGRAM_PORT=8005
        # MCP_ADVANCED_MEMORY_PORT=8006 # Пока не используется
        MCP_SEMANTIC_MEMORY_PORT=8007

        # Рабочая директория для MCP_Files (можно оставить по умолчанию)
        # MCP_FILES_BASE_DIR="./workspace"
        ```

## Запуск системы

Система состоит из главного GUI приложения и нескольких MCP-сервисов, работающих параллельно. Для правильной работы **необходимо сначала запустить все нужные MCP, а затем GUI**.

Предполагается, что вы создадите стартовый скрипт (например, `start.bat` для Windows или `start.sh` для Linux/macOS), который автоматизирует этот процесс.

Пример `start.bat` (для Windows):

```bat
@echo off
start cmd /k "python mcp_files.py"
timeout /t 2 > nul
start cmd /k "python mcp_web.py"
timeout /t 2 > nul
start cmd /k "python mcp_shell.py"
timeout /t 2 > nul
start cmd /k "python mcp_clipboard.py"
timeout /t 2 > nul
start cmd /k "python mcp_telegram.py"
timeout /t 2 > nul
start cmd /k "python mcp_semantic_memory.py"
timeout /t 2 > nul

echo Ожидание запуска MCP...
timeout /t 10 > nul

echo Запуск основного приложения...
python main.py

echo Основное приложение завершено.
exit
```

*(Примечание: `timeout /t 2 > nul` добавляет короткую паузу между запусками, чтобы дать каждому сервису немного времени для старта. `cmd /k` оставляет окна терминала открытыми после завершения скрипта MCP, что удобно для отладки.)*

Пример `start.sh` (для Linux/macOS):

```bash
#!/bin/bash
gnome-terminal -- python mcp_files.py &
sleep 2
gnome-terminal -- python mcp_web.py &
sleep 2
gnome-terminal -- python mcp_shell.py &
sleep 2
gnome-terminal -- python mcp_clipboard.py &
sleep 2
gnome-terminal -- python mcp_telegram.py &
sleep 2
gnome-terminal -- python mcp_semantic_memory.py &
sleep 2

echo "Waiting for MCPs..."
sleep 10

echo "Starting main application..."
python main.py

echo "Main application finished."
```

*(Примечание: `gnome-terminal --` используется для запуска в новом окне терминала в GNOME. В KDE это может быть `konsole -e`, в macOS `osascript -e 'tell application "Terminal" do script "cd <project_path> && python mcp_files.py"' &`, и т.д. Или можно запускать в фоне `python mcp_files.py &`, но тогда логи будут смешаны.)*

**Рекомендуемый способ запуска:**

1.  Откройте терминал/командную строку в корне проекта.
2.  Запустите каждый файл `mcp_*.py` (который вы хотите использовать) в **отдельном** терминале/процессе.
3.  Убедитесь, что MCPs успешно стартовали и выводят сообщение о прослушивании порта. Для Telegram MCP потребуется войти в аккаунт при первом запуске.
4.  После запуска MCPs, в новом терминале запустите `python main.py`.

`main.py` автоматически проверит доступность MCPs перед запуском GUI. Если какой-то обязательный MCP не запустится, `main.py` сообщит об ошибке и завершится.

## Использование GUI

После запуска `main.py` появится основное окно приложения:

*   **Левая панель:** Список существующих чатов.
    *   `Новый чат`: Начинает новую беседу, очищая историю в центральной панели.
    *   `Удалить чат`: Удаляет выбранный чат.
*   **Центральная панель (верхняя):** Область для отображения истории текущего чата. Сообщения пользователя и ИИ форматируются для удобства чтения.
*   **Центральная панель (нижняя):**
    *   Поле ввода для ввода команд и вопросов ИИ.
    *   Кнопка `Отправить` для отправки сообщения.
*   **Нижняя панель:** Логи работы системы и вызовов MCP. Это полезно для понимания того, что именно делает ИИ "под капотом".
*   **Верхняя область:**
    *   Выбор языковой модели (при первом запуске загружается список из API).
    *   Кнопка `Сохранить модель` для сохранения выбранной модели в `.env` файл.
    *   Кнопка `Настройки` для открытия диалога настроек (тема, шрифты).
*   **Строка состояния:** Отображает текущее действие ИИ (например, "Отправка запроса ИИ...", "Выполняю: read_file(...)").

### Чат

Введите свой запрос в поле ввода и нажмите `Отправить`. ИИ обработает запрос. Если для выполнения задачи требуются инструменты, вы увидите процесс "Мысль -> Действие" в логах и статус выполнения в строке состояния. Финальный, понятный для пользователя ответ ИИ появится в истории чата.

### Управление чатами

*   Чтобы начать новый чат, нажмите `Новый чат`.
*   Чтобы загрузить предыдущий чат, выберите его из списка.
*   Чтобы удалить чат, выберите его и нажмите `Удалить чат`.

История чатов автоматически сохраняется после каждого ответа ИИ.

### Настройки

Кнопка `Настройки` открывает диалог, где вы можете:
*   Выбрать цветовую тему (`light` или `dark`).
*   Настроить размер шрифта для истории чата и логов.

Изменения применяются сразу после нажатия "ОК" и сохраняются в `settings.json`.

## Как ИИ использует инструменты (MCPs)

`ai_interface.py` действует как мозг, связывающий ИИ (LLM) с инструментами (MCPs).

1.  При получении нового пользовательского сообщения, ИИ вызывается с историей чата и описаниями доступных функций MCP (JSON схемы).
2.  ИИ, основываясь на запросе пользователя и истории, решает:
    *   Либо дать прямой текстовый ответ (Режим Чат-бота), если запрос простой.
    *   Либо перейти в Режим Агента для выполнения сложной задачи, которая требует использования MCP.
3.  В Режиме Агента, ИИ последовательно выполняет шаги:
    *   **Мысль (Thought):** Генерирует внутренний текст, описывающий его план или текущую задачу. (Этот шаг может быть неявно встроен в некоторые модели).
    *   **Действие (Action):** Генерирует вызов одного или нескольких доступных MCP-инструментов, указывая имя функции и параметры в JSON формате.
4.  `ai_interface.py` перехватывает эти вызовы, находит соответствующий зарегистрированный MCP сервер и отправляет JSON-RPC запрос.
5.  MCP выполняет запрошенную операцию (например, читает файл, отправляет сообщение, кликает на странице) и возвращает результат главному приложению.
6.  `ai_interface.py` добавляет результат выполнения инструмента в историю сообщений (как `role: tool`).
7.  Обновленная история (включающая результат действия) снова отправляется ИИ.
8.  Цикл повторяется. ИИ анализирует результат предыдущего действия и генерирует следующую "Мысль" или "Действие".
9.  Когда ИИ определит, что задача выполнена и у него достаточно информации для ответа на **изначальный** запрос пользователя, он завершает Режим Агента (например, просто возвращая текстовый ответ без вызова инструментов).
10. `ai_interface.py` использует отдельный вызов ИИ (`_summarize_for_user`) для синтеза финального ответа на основе всего цикла "Мысль -> Действие -> Результат" в понятный для пользователя формат.

Пользователь в GUI видит только свой запрос, финальный ответ ИИ и, опционально, подробности в панели логов. Промежуточные шаги "Мысли" и "Действия" скрыты от основной беседы, чтобы не загромождать ее.

## Подробнее о MCPs

Каждый файл `mcp_*.py` - это отдельное веб-приложение на Flask (запускаемое через Waitress), предоставляющее набор инструментов через два эндпоинта:
*   `/functions` (GET): Возвращает JSON с описанием доступных функций для ИИ.
*   `/mcp` (POST): Принимает JSON-RPC запросы на выполнение конкретных функций.

### MCP_Files (`mcp_files.py`)

*   **Рабочая директория (`./workspace`):** Все операции с файлами строго ограничены поддиректорией `workspace` (или той, что указана в `MCP_FILES_BASE_DIR` в `.env`). Это реализовано с помощью функции `_get_safe_path`, которая проверяет, что запрошенный путь находится внутри рабочей директории, предотвращая попытки выхода за ее пределы (например, через `../`).
*   **Функции:** `list_dir`, `read_file`, `write_file`, `delete_file`.
*   ИИ должен использовать `list_dir` для проверки наличия файлов перед чтением или удалением. Функция `write_file` ограничена "КОРОТКИМ" текстом (это скорее семантическое ограничение для ИИ в промпте, технически ограничение на размер текста может быть добавлено на уровне MCP).

### MCP_Shell (`mcp_shell.py`)

*   **Белый список команд (`ALLOWED_COMMANDS`):** ИИ может выполнять только команды, строго определенные в `ALLOWED_COMMANDS`. Это критично для безопасности. ИИ указывает "имя команды" (`command_name`) из этого списка, а MCP использует соответствующую реальную команду.
*   **Функции:** `execute_shell_command`, `get_current_time`.
*   `get_current_time` предоставляет текущую дату/время с помощью Python `datetime`, не через вызов внешней команды, что надежнее.

### MCP_Clipboard (`mcp_clipboard.py`)

*   **Зависимость:** Использует библиотеку `pyperclip`.
*   **Функции:** `get_clipboard_content`, `set_clipboard_content`.

### MCP_Web (`mcp_web.py`)

*   **Зависимость:** Использует `selenium` (требует ChromeDriver).
*   **Имитация человека:** Добавлены настройки Selenium для маскировки под обычный браузер.
*   **Ограничение:** Анализирует и возвращает ИИ только **видимые** интерактивные элементы (ссылки, поля ввода, кнопки) сгенерированными ID, чтобы ИИ мог взаимодействовать со страницей, но не имел прямого доступа ко всей DOM структуре.
*   **Функции:** `navigate_to_url`, `get_page_content`, `click_element`, `type_in_element`.
*   Функция `get_page_content` возвращает ограниченный по длине текст страницы и список интерактивных элементов с их ID. ИИ должен использовать эти ID для `click_element` и `type_in_element`.

### MCP_Telegram (`mcp_telegram.py`)

*   **Зависимость:** Использует `telethon` (требует API ID/Hash).
*   **Асинхронность:** Работает в отдельном потоке с asyncio event loop для взаимодействия с Telegram API.
*   **Использование dialog_id:** Функции для отправки/чтения сообщений требуют `dialog_id`. ИИ **обязан** сначала вызвать `list_telegram_dialogs` для получения актуальных ID диалогов и использовать только их. Использование придуманных или неактуальных ID приведет к ошибке.
*   **Функции:** `send_telegram_message`, `list_telegram_dialogs`, `read_last_messages`, `get_chat_participants`.

### MCP_Semantic_Memory (`mcp_semantic_memory.py`)

*   **Хранилище:** Использует SQLite для текстов, FAISS для векторов, NetworkX для графа. Данные сохраняются в файлы: `semantic_memory.db`, `semantic_memory.index`, `knowledge_graph.json`.
*   **Векторная память:** Позволяет ИИ запоминать факты/идеи (`remember`) и искать по смыслу (`recall`). Используется Sentence-Transformer модель ('paraphrase-multilingual-MiniLM-L12-v2'). Инициализация модели происходит лениво при первом вызове любой функции или при старте `if __name__ == "__main__":`, что может занять время и потребовать скачивания модели.
*   **Граф знаний:** Позволяет ИИ создавать узлы (сущности - люди, проекты, места) и связывать их между собой. Полезно для идентификации и понимания отношений. ИИ может искать сущности по имени (`find_entity_by_label`) и получать их связи (`get_entity_details`).
*   **Функции:** `remember`, `recall`, `create_entity`, `link_entities`, `find_entity_by_label`, `get_entity_details`, `update_entity_label`.

## Безопасность и Ограничения

*   **Песочница файловой системы:** Доступ ИИ ограничен поддиректорией `workspace`.
*   **Белый список команд Shell:** Выполняются только явно разрешенные команды.
*   **Отдельные процессы:** MCPs изолированы от основного приложения.
*   **Ограничения Selenium:** ИИ видит и может взаимодействовать только с видимыми элементами по сгенерированным ID, не имеет полного доступа к браузеру или DOM.
*   **Зависимость от API:** Работоспособность ИИ зависит от доступности и правильной настройки API ключей и URL (OpenAI/другой LLM, Telegram).
*   **Требуется локальная настройка:** Для полного функционала необходимо настроить `.env`, установить зависимости, ChromeDriver и, при первом запуске Telegram MCP, авторизоваться.

## Возможные улучшения

*   Автоматический запуск и управление MCPs (например, с использованием Docker Compose, Poetry run, или отдельного скрипта управления процессами).
*   Расширение "белого списка" команд Shell с более гибким парсингом аргументов (с сохранением безопасности).
*   Реализация MCP для других сервисов/устройств (например, календарь, почта, уведомления).
*   Улучшение веб-интерфейса MCP_Web (более надежный поиск элементов, скриншоты).
*   Более сложные структуры в семантической памяти (триплеты, контекст).
*   Интеграция с другими LLM провайдерами или локальными моделями через универсальный интерфейс.
*   Голосовой ввод/вывод.
*   Поддержка работы с файлами не только в текстовом формате.

## Лицензия

Проект распространяется под лицензией MIT. См. файл `LICENSE`.

## Вклад

Приветствуется вклад в развитие проекта! Пожалуйста, создавайте pull-реквесты или открывайте issues на GitHub.
